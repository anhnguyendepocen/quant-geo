---
title: "Making Graphs"
author: "James B. Elsner"
date: September 18, 2018
output: 
  html_document:
    keep_md: true
---

## Grammer for graphs

The **ggplot2** package has functions for making informative graphics. The 'gg' stands for the 'Grammar of Graphics,' a theory of how to create a graphics system from Leland Wilkinson.

The grammar specifies how a plot translates data to attributes of geometric objects. Attributes are things like color, shape, and size and the geometric objects are things like points, lines, bars, and polygons.

A plot is drawn using a coordinate system and it may contain manipulations of the data. Faceting replicates the plot using subsets of the data (like the `group_by()` function).

The plot type depends on the geometric object, which is specified as a function. The function name begins with `geom_`. For example, to create a histogram the `geom_histogram()` function is used.

Load the **ggplot2** package.
```{r}
library(ggplot2)
```

Make sure you have a call to the package load function (`library()`) in your code before you knit.

http://r4ds.had.co.nz/exploratory-data-analysis.html

### Bar chart

Read the hurricane data from the file on my website and list the first six rows.
```{r}
loc <- "http://myweb.fsu.edu/jelsner/temp/data/US.txt"
H <- read.table(loc, header = TRUE)
head(H)
```

The function `table()` creates a frequency table from the landfall counts.
```{r}
table(H$All)
```

The number of cases for each count is tallied and displayed below the count. There were 36 cases of 0 hurricanes. Each case is a year.

The function `geom_bar()` creates a bar chart of this frequency table.
```{r}
ggplot(data = H) + 
  geom_bar(mapping = aes(x = All))
```

With **ggplot2**, we begin a plot with the function `ggplot()`. `ggplot()` creates a coordinate system that we can add layers to. The first argument of `ggplot()` is the dataset to use in the graph. So `ggplot(data = H)` creates an empty graph.

We complete our graph by adding one or more layers to `ggplot()`. The function `geom_bar()` adds a layer of bars to our plot, which creates a bar chart. **ggplot2** comes with many `geom_` functions that each add a different type of layer to a plot.

Each `geom_` function takes a mapping argument. This defines how variables in our dataset are mapped to visual properties. The mapping argument is always paired with `aes()` function, and the `x` argument of `aes()` specifies which variables to map to the x axes, in this case `All`. `ggplot()` looks for the mapped variable in the data argument, in this case, `H`.

The function `geom_bar()` tables the counts and then maps the number of cases to bars with the bar height proportional to the number of cases. Here the number of cases is the number of years with that many hurricanes.

The functions are applied in order (`ggplot()` comes before `geom_bar()`) and are linked with the addition `+` symbol. In this way we can think of the functions as layers in a GIS.

The bar chart contains the same information as displayed by the function `table()`. The y-axis label is 'count' and x-axis label is the column name. 

Repeat this time using Florida hurricane counts. The annual number of Florida hurricanes by year is given in column `FL` in the data frame `H`.
```{r}
H$FL
```

The `geom_bar()` function tables these numbers and plots the frequency as a bar.
```{r}
ggplot(data = H) + 
  geom_bar(mapping = aes(x = FL)) +
  xlab("Number of Florida Hurricanes (1851-2016)") +
  ylab("Number of Years")
```

Here axes labels are placed on the plot with the functions `ylab()` and `xlab()`. With this type of 'layering' it's easy to go from data on the web to a publishable plot.

### Beer preference

Thirty graduate students are surveyed about their beer drinking preferences. Categories are (1) domestic can, (2) domestic bottle, (3) microbrew, and (4) import. To make a bar chart first create the data as a character vector and then change the vector to a data frame.
```{r}
beer <- c(rep('domestic bottle', 4), 
         rep('domestic can', 12), 
         rep('import', 5), 
         rep('microbrew', 9))
beerPref.df = as.data.frame(beer)
```

Use the function `str()` to see the column types in the data frame.
```{r}
str(beerPref.df)
```

There is one column in the data frame with the name `beer`. It is a factor with 4 levels one for each type of beer choice. A factor is a categorical vector. It looks like a character but it can be ordered. This is important when factors are used in statistical models.

Create a table.
```{r}
table(beerPref.df$beer)
```

Create a bar chart and specify the axis labels.
```{r}
ggplot(data = beerPref.df) + 
  geom_bar(mapping = aes(beer)) +
  xlab("Beer Preference") + 
  ylab("Number of Students")
```

This is a good start but a few improvements should be made.

1. The bar order is alphabetical from left to right. This is the default ordering for factors created from character vectors. It is much easier to make comparisons if frequency determines the order.

To change the order on the bar chart specify the factor levels on the vector beer.
```{r}
beer <- factor(beer, levels = c("domestic can", "microbrew", "import", "domestic bottle"))
beerPref.df <- data.frame(beer)
```

Now remake the bar chart.
```{r}
ggplot(beerPref.df) + 
  geom_bar(mapping = aes(beer)) +
  xlab("Beer Preference") + 
  ylab("Number of Students")
```

2. The vertical axis tic labels are fractions. Since the bar heights are counts (integers) the tic labels also should be integers.

To override this default you add a new y-axis layer. The layer is the function `ylim()` where you indicate the lower and upper limits of the axis with the concatenate (`c()`) function. Now remake the bar chart.
```{r}
ggplot(beerPref.df) + 
  geom_bar(mapping = aes(beer)) +
  xlab("Beer Preference") + 
  ylab("Number of Students") +
  ylim(c(0, 15))
```

Now the chart is publishable and this schema works for print media. Options exist for changing the look of the plot for digital media include, colors, orientation, background, etc.

For example to change the bar color use the `fill =` argument in the function `geom_bar()`. To change the orientation of the bars use the layer function `coord_flip`, and to change the background use the layer function `theme_minimal()`

We make changes to the look of the plot with additional layers.
```{r}
ggplot(beerPref.df) + 
  geom_bar(mapping = aes(beer), fill = "orange2") +
  xlab("Beer Preference") + 
  ylab("Number of Students") +
  ylim(c(0, 15)) +
  coord_flip() +
  theme_minimal()
```

Note that the `fill =` is used on the variable named in the `aes()` function but it is specified outside the `aes()` function.

Available colors include 
```{r eval=FALSE}
colors()
```

It's a bit more complicated to automatically change the bar order based on the frequency of occurrence. Here is an example for storm intensity of tropical cyclones during 2017.
```{r}
minP <- c(990, 1007, 992, 1007, 1005, 981, 967, 938, 914, 938, 972, 971)
name <- c("Arlene", "Bret", "Cindy", "Don", "Emily", "Franklin", "Gert", 
         "Harvey", "Irma", "Jose", "Katia", "Lee")

df <- data.frame(name, minP) %>%
  mutate(name = reorder(name, minP))

ggplot(df) + 
  geom_bar(mapping = aes(x = name, y = minP), stat = "identity") +
  ylab("Minimum Sea Level Pressure [mb]") 
```

The key is the function `reorder()`, which treats its first argument as a categorical factor variable and reorders the levels of this factor based on the values of the variable in the second argument.

### Histogram

The histogram is similar to the bar chart except the histogram uses bars to indicate frequency (or proportion) over an interval of continuous values. For instance, with continuous values the function `table()` is not useful.
```{r}
x <- rnorm(10)
table(x)
```

So neither is a bar plot.

A histogram is made as follows: First a contiguous collection of disjoint intervals, called bins, covering the range of data points is chosen.  "Disjoint" means no overlap, so the intervals look like (a,b] or [a,b). The interval (a,b] means the interval contains all the values from a to b including b but not a, whereas the interval [a,b) means the interval contains all the values from a to b including a but not b.

Second, the number of data values in each of these intervals is counted. Third, a bar is drawn above the interval so that the area of the bar is proportional to the frequency. If the intervals defining the bins have the same width, then the height of the bar is proportional to the frequency (the number of values inside the interval).

Let's return to the Florida precipitation data.
```{r}
loc <- "http://myweb.fsu.edu/jelsner/temp/data/FLprecip.txt"
FLp <- read.table(loc, 
                  na.string = "-9.900", 
                  header = TRUE)
str(FLp)
```

Columns in the data frame `FLp` are months (variables) and rows are years. `Year` is an integer (int) vector and the months are numeric (num) vectors. Create a histogram of May precipitation.
```{r}
ggplot(data = FLp) + 
  geom_histogram(mapping = aes(May))  +
  xlab("May Precipitation in Florida (in)") 
```

By default the function `geom_histogram()` picks 30 bins. Since there are only 118 May values many of the bins have fewer than 5 values.

When making a histogram you will almost certainly need to vary the number of bins before deciding on a final plot. This can be done with the `bins =` or `binwidth =` argument. For example, the look of the histogram is improved by halving the default number of bins.
```{r}
ggplot(data = FLp) + 
  geom_histogram(mapping = aes(May), bins = 15)  +
  xlab("May Precipitation in Florida (in)") 
```

It looks even better by decreasing the number of bins to 11.
```{r}
ggplot(FLp) + 
  geom_histogram(mapping = aes(May), bins = 11, fill = "green3")  +
  xlab("May Precipitation in Florida (in)") +
  ylab("Number of Years")
```

Here the fill argument is used to change color and a `ylab()` layer is added to make the y-axis label more concise.

The `geom_rug()` layer adds the location of the data values as tic marks just above the horizontal axis.
```{r}
ggplot(FLp) + 
  geom_histogram(mapping = aes(May), bins = 11, fill = "green3")  +
  xlab("May Precipitation in Florida (in)") +
  ylab("Number of Years") +
  geom_rug()
```

### Density plot

A density plot is a smoothed histogram with units of probability on the vertical axis. It's motivated by the fact that for a continuous variable, the probability that X takes on any particular value x is 0 so we need a range of values over which we can define a probability.

The probability density answers the question, what is the chance that X falls in a small interval. This chance varies depending on where X is located (e.g., near the middle of the distribution the chance is highest).
```{r}
ggplot(FLp) +
  geom_density(mapping = aes(May)) +
  xlab("May Precipitation in Florida (in)")
```

The probability axis (vertical) is the integral (average) chance that rainfall will take on a value along the horizontal axis within a given small interval. The size of the interval is determined by the bandwidth (`bw =`).
```{r}
ggplot(FLp) +
  geom_density(mapping = aes(May), bw = 1) +
  xlab("May Precipitation in Florida (in)")
```

The probability scale depends on the data units so it is often tricky to interpret. Instead `geom_freqpoly()` produces a density-like graph where the units on the y-axis are counts as with the histogram.
```{r}
ggplot(FLp) + 
  geom_freqpoly(mapping = aes(May), color = "green3", binwidth = 1) +
  xlab("May Precipitation in Florida (in)") +
  geom_rug()
```

### Box plot

The box plot graphs five summary statistics including the min, max, 1st & 3rd quartiles, and the median. The easiest way to create a box plot is to use the function `boxplot()`.
```{r}
boxplot(FLp$May)
```

The function `boxplot()` is from the base **graphics** package. Others from this package include `hist()` for histograms and `plot()` for scatter plots. 

The base graphics lets you manipulate every detail of a graph, which is great for customization. For example:
```{r}
boxplot(FLp$May, 
        ylab = "May Precipitation in FL (in)")
f <- fivenum(FLp$May)
text(rep(1.3, 5), f, labels = c("Minimum", "1st Quartile", 
                                "Median", "3rd Quartile",
                                "Maximum"))
text(1.3, 7.792, labels = "Last Value Within\n 1.5xIQR Above 3rd Q")
```

The box plot illustrates the five numbers graphically. The median is the line through the box. The bottom and top of the box are the 1st and 3rd quartile values. Whiskers extend vertically from the box downward toward the minimum and upward toward the maximum. 

If values extend beyond 1.5 times the interquartile range (either above or below the corresponding quartile) the whisker is truncated at the last value within the range and points are used to indicate outliers.

To make a box plot using the function `ggplot()` you need a dummy variable for the `x` argument in the function `aes()`. This is done with `x = ""`.
```{r}
ggplot(FLp) + 
  geom_boxplot(mapping = aes(x = "", y = May)) +
  xlab("") + 
  ylab("May Precipitation in Florida (in)")
```

### Side-by-side box plots

Suppose we want to show box plots for each month. In this case we make the x argument in the `aes()` the name of a column containing the vector of month names. Since the data frame is in a wide format, you need to reshape it.

Use `gather()` from the **tidyr** package.
```{r}
library(tidyr)
head(FLp)
FLpL <- FLp %>%
  gather(key = Year,
         value = "Precipitation",
         factor_key = TRUE)
head(FLpL)
```

The `gather()` function takes all the values as measured except those named in `key = ` argument. All variables are measured (precipitation in units of inches) except `Year`. `Year` is a vector identifying the year. 

The long data frame lists the key variable names as the first column taking the column names as character strings starting with `Jan`. To preserve the order of the columns (e.g., January comes before February, etc) we specify the `factor_key = TRUE`.

To create the box plot specify that the x-axis be the variable.
```{r}
ggplot(FLpL) + 
  geom_boxplot(mapping = aes(x = Year, y = Precipitation)) +
  xlab("Month") + 
  ylab("Precipitation (in)")
```

This is a climograph.

Each `geom_` function is a layer. Data for the layer is specified in the function `ggplot()` with the data frame argument and the `aes()` function. To add another layer to the plot with different data you specify the data within the geom function. For example, lets repeat the climograph of monthly precipitation highlighting the month of May.

We add another `geom_boxplot()` layer and specify a subset of the data using the subset `[]` operator.
```{r}
ggplot(FLpL, aes(x = variable, y = value)) + 
  geom_boxplot() +
  xlab("Month") + 
  ylab("Precipitation (in)") +
  geom_boxplot(data = FLpL[FLpL$variable == "May", ], 
               aes(x = variable, y = value), 
               fill = "green")
```

Practice: Make a climograph from the monthly SOI data. Here I put the functions in the proper order but I left out some details.
```{r eval=FALSE}
loc <- "http://myweb.fsu.edu/jelsner/temp/data/SOI.txt"
SOI <- read.table(file = ,
                  header = TRUE)
SOIL <- SOI %>%
  gather(key = , value = Index)
ggplot(SOIL) + 
  geom_boxplot(mapping = aes(x = , y = )) +
  ylab("SOI (s.d.)")
```

### Scatter plot

The work horse of statistical graphs is the scatter plot. It's a graph of the values of one variable against the values of the other as points $(x_i, y_i)$ in a Cartesian plane. It's used to show the relationship between two numeric variables. 

For example, to show the relationship between April and September values of Florida precipitation type
```{r}
ggplot(FLp) + 
  geom_point(mapping = aes(x = Apr, y = Sep)) + 
  xlab("April Precip. (in)") + 
  ylab("September Precip. (in)")
```

The plot shows that dry Aprils tend to be followed by dry Septembers and wet Aprils tend to be followed by wet Septembers. We observe there is a direct (or positive) relationship between the two variables although the points are scattered widely indicating the relationship is weak.

If our goal is to model the relationship, we plot the dependent variable (the variable we are interested in modeling) on the vertical axis. Here we put the September values on the vertical axis since a predictive model would use April values to forecast September values.

If the points have a natural ordering then we use the `geom_line()` function. For example, to plot the September precipitation values as a time series type
```{r}
ggplot(FLp) + 
  geom_line(mapping = aes(x = Year, y = Sep)) + 
  xlab("Year") + 
  ylab("September Precip. (in)")
```

Precipitation values fluctuate from one September to the next, but there does not appear to be a long-term trend. With time series data it is better to connect the values with lines rather than use points unless values are missing.

Practice: Create a plot of the May values of the North Atlantic oscillation (NAO) with Year on the horizontal axis. Add appropriate axis labels.
```{r eval=FALSE}
L = "http://myweb.fsu.edu/jelsner/temp/data/NAO.txt"
NAO = read.table(file = L, header = TRUE)
ggplot(NAO, aes(x = Year, y = May)) + 
  geom_line() + 
  xlab("Year") + 
  ylab("North Atlantic Oscillation (s.d.)")
```

### Graphs for communication

Adding labels turns our exploratory graphic into an expository graphic. For example consider the `mpg` dataset and plot highway mileage (`hwy`) as a function of engine size (`displ`) with the color of the point layer given by automobile class (`class`).
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size")
```

The purpose of a plot title is to summarise the main finding. Avoid titles that just describe what the plot is, e.g. "A scatterplot of engine displacement vs. fuel economy". If you need to add more text, there are two other useful labels.

* `subtitle =` adds additional detail in a smaller font beneath the title.
* `caption = ` adds text at the bottom right of the plot, often used to describe the source of the data.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size",
       subtitle = "Two seaters (sports cars) are an exception because of their light weight",
       caption = "Data from fueleconomy.gov")
```

### Create a plot object

The assignment operator can be used to save the plot as an object. The object can be modified and printed.

Example: Given the 'cars' data frame from the **datasets** package. 
```{r}
str(cars)
```

Plot the car's stopping distance (`dist`) on the vertical (y) axis and the car's forward speed (`speed`) on the horizontal axis (x). Create the plot but assign it to an object called `p`.
```{r}
p = ggplot(cars, aes(x = speed, y = dist)) +
        geom_point() +
        xlab("Forward Speed (mph)") +
        ylab("Stopping Distance (ft)")
p
p = p + theme_bw()
p
p + geom_rug()
```

Notes:

1. the `aes()` function creates a list of variables to map. Here speed and dist from the data frame cars. The default argument list is ordered with the x variable first then the y variable, but it is good coding practice to name them using `x =` , etc.
2. The first layer is `geom_point()`. It maps the aesthetics to a cartesian plane. The `geom_point()` function needs an x and y aesthetic, but also understands `color`, `fill`, `shape`, `size`, `alpha`.
3. The second and third layers add labels to the axes. 
4. The graph is first saved as an object called `p` rather than rendered by the graphical device. It gets rendered by typing its name.
5. Additional layers are added to `p` using the `+` symbol.

The ggplot object `p` is a list of length 9 elements. Type
```{r, eval=FALSE}
str(p)
```

The first element is the data frame. The last element are the labels.

### Export a graph

When you knit to HTML and a plot is produced it gets output as a png file in a folder called "figure" in the directory where your .Rmd file is located.

You can also use the Export button under the Plots tab.

Or you can export the file directly using R code. Here the file gets put into your working directory.
```{r eval = FALSE, dev=c("pdf", "png")}
png(file = "MayNAO.png")
ggplot(NAO, aes(x = Year, y = May)) + 
  geom_line() + 
  xlab("Year") + 
  ylab("May NAO (s.d.)")
dev.off()
```

Note that the function `png()` opens the device and the function `dev.off()` closes it.  

Recall to list the files in your working directory type `dir()`.

My workflow. 

### Give it a try

Use the `cars` data frame (**datasets**) to create a histogram and box plot of stopping distance (column name `dist`). Also create a scatter plot of stopping distance (`dist`) versus `speed` with `speed` on the horizontal axis.
